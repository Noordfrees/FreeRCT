/*
 * This file is part of FreeRCT.
 * FreeRCT is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
 * FreeRCT is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with FreeRCT. If not, see <http://www.gnu.org/licenses/>.
 */

/** @file rev.cpp Autogenerated file with the revision and such of FreeRCT. */

#include "rev.h"
#include "stdafx.h"
#include "fileio.h"
#include <optional>

#if _WIN32
#include <Windows.h>
#elif defined(__linux__)
#include <unistd.h>
#endif

/**
 * The text version of FreeRCT's revision.
 * This will be either "<major>.<minor>.<build>[-RC<rc>]",
 * "<commitdate YYYYmmdd-HHMM>.<vcs type><identifier>" or "norev.n000".
 *
 * The major, minor and build are the numbers that describe releases of
 * FreeRCT (like 0.5.3). "-RC" is used to flag release candidates.
 * Note: This format is not yet implemented in the configure script.
 *
 * The revision number is fairly straight forward. The first part is the
 * date of the last commit, in the format "%Y%m%d-%H%M", followed by a
 * '.', and then a VCS tag - 'r' for svn (including hgsvn and git svn),
 * 'h' for hg, and 'g' for git checkouts. This is finally followed by
 * the revision for that VCS.
 * e.g. 20130921-0929.r870
 *
 * norev.n000 is for non-releases that are made on systems where no VCS
 * detection was possible.
 */
const char _freerct_revision[] = "${VERSION_STRING}";

/**
 * The text version of FreeRCT's build date.
 * Updating the build date in this file is the safest as it generally gets
 * updated for each revision in contrary to most other files that only see
 * updates when they are actually changed themselves.
 */
const char _freerct_build_date[] = __DATE__ " " __TIME__;

static std::string _freerct_install_prefix("${CMAKE_INSTALL_PREFIX}/${PACKAGING_DATA_DIR}");  ///< The location where all FreeRCT assets are installed.
static std::string _freerct_userdata_prefix_override("${USERDATA_PREFIX}");                   ///< NOLINT â€“ clang-tidy may produce a false-positive here.
                                                                                              ///< A manually defined user data location.
static std::optional<std::string> _freerct_userdata_prefix_cache;                             ///< Cache for the result of #freerct_userdata_prefix.
static std::optional<std::string> _freerct_executable_prefix_cache;                           ///< Cache for the result of #executable_prefix.

/**
 * Change the location where all FreeRCT assets are installed.
 * This should be called only during startup.
 * @param dir The path.
 */
void OverrideUserdataPrefix(const char *dir)
{
	_freerct_userdata_prefix_override = dir;
	_freerct_userdata_prefix_cache = std::nullopt;
}

/**
 * The location where all FreeRCT assets are installed if "make install" was called.
 * @return The path.
 */
const std::string &freerct_install_prefix()
{
	return _freerct_install_prefix;
}

/**
 * Change the location where all FreeRCT assets are installed.
 * This should be called only during startup.
 * @param dir The path.
 */
void OverrideInstallPrefix(const char *dir)
{
	_freerct_install_prefix = dir;
}

/**
 * The FreeRCT installation directory based on where the FreeRCT executable is located.
 * @return The path.
 */
const std::string &freerct_executable_prefix()
{
	if (_freerct_executable_prefix_cache.has_value()) return *_freerct_executable_prefix_cache;

	char executable_filepath[MAX_PATH];
#if _WIN32
	GetModuleFileNameA(nullptr, executable_filepath, MAX_PATH);
#elif defined(__linux__)
	int l = readlink("/proc/self/exe", executable_filepath, MAX_PATH);
	executable_filepath[std::max(l, 0)] = '\0';
#else
	/* \todo Extend for MacOS and others. */
	executable_filepath[0] = '\0';
#endif

	if (executable_filepath[0] != '\0') {
		std::filesystem::path installpath(executable_filepath);
		installpath = installpath.parent_path().parent_path();
		installpath /= "share";
#ifdef __linux__
		installpath /= "games";
#endif
		installpath /= "freerct";
		_freerct_executable_prefix_cache = installpath.string();
	} else {
		printf(
			"WARNING: Unable to detect the executable's directory!\n"
			"Using fallback path: %s\n"
			"Use `--installdir DIR` in case the program fails to start.\n",
			freerct_install_prefix().c_str());
		_freerct_executable_prefix_cache = std::string();
	}

	return *_freerct_executable_prefix_cache;
}

/**
 * The location where the user's savegames and other data is stored.
 * @return The path.
 */
const std::string &freerct_userdata_prefix()
{
	if (_freerct_userdata_prefix_cache.has_value()) return *_freerct_userdata_prefix_cache;

	if (!_freerct_userdata_prefix_override.empty()) {
		/* The user manually set a location. */
		_freerct_userdata_prefix_cache = _freerct_userdata_prefix_override;
	} else {
		/* Try to follow the XDG basedir specification. */
		const char *xdg_data_home = getenv("XDG_DATA_HOME");
		if (xdg_data_home != nullptr && xdg_data_home[0] != '\0') {
			_freerct_userdata_prefix_cache = xdg_data_home;
			*_freerct_userdata_prefix_cache += DIR_SEP;
			*_freerct_userdata_prefix_cache += "freerct";
		} else {
			/* The XDG spec is not applicable, fall back to a reasonable default path. */
			_freerct_userdata_prefix_cache = GetUserHomeDirectory();
#ifdef _WIN32
			*_freerct_userdata_prefix_cache += "\\.freerct";
#else
			*_freerct_userdata_prefix_cache += "/.local/share/freerct";
#endif
		}
	}

	return *_freerct_userdata_prefix_cache;
}
